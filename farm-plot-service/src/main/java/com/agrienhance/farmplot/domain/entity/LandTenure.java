package com.agrienhance.farmplot.domain.entity;

import com.agrienhance.farmplot.domain.enums.LandTenureType;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.*;
import org.hibernate.annotations.UuidGenerator;

import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.UUID;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(of = "landTenureIdentifier") // Base on its own ID
@ToString(of = { "landTenureIdentifier", "tenureType", "plotIdentifierForToString" })
@Entity
@Table(name = "land_tenures", indexes = {
        @Index(name = "idx_landtenures_tenant_id", columnList = "tenant_id")
// A unique constraint on plot_identifier can enforce the OneToOne nature at DB
// level too
// if Plot is the owner of the relationship from the Plot side.
// If LandTenure is the owner, then plot_identifier here should be unique.
})
public class LandTenure {

    @Id
    @GeneratedValue
    @UuidGenerator
    @Column(name = "land_tenure_identifier", updatable = false, nullable = false)
    private UUID landTenureIdentifier;

    // This establishes a one-to-one relationship where LandTenure is the "owning"
    // side
    // if Plot does not have a mappedBy field pointing back to this.
    // Or, if Plot has a @OneToOne(mappedBy="plot", cascade=CascadeType.ALL)
    // LandTenure tenure;,
    // then Plot is the owner. Let's assume Plot is the owner for simplicity,
    // and LandTenure is associated via a direct link to Plot.
    // For a true shared primary key OneToOne, the @Id of LandTenure could be the
    // Plot itself.
    // Let's use a simpler foreign key approach first.

    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "plot_identifier", referencedColumnName = "plot_identifier", nullable = false, unique = true)
    // Ensure this plot_identifier is unique to enforce OneToOne from this side if
    // LandTenure "owns" the FK.
    private Plot plot;

    @NotNull
    @Enumerated(EnumType.STRING) // Store enum as string in the database
    @Column(name = "tenure_type", nullable = false, length = 50)
    private LandTenureType tenureType;

    @Column(name = "lease_start_date")
    private LocalDate leaseStartDate; // Use java.time.LocalDate for dates without time

    @Column(name = "lease_end_date")
    private LocalDate leaseEndDate;

    @Lob
    @Column(name = "owner_details") // e.g., if leased, details of the lessor
    private String ownerDetails;

    @Column(name = "agreement_document_reference", length = 255)
    private String agreementDocumentReference; // e.g., path or ID to a document in object storage

    @NotNull
    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @NotNull
    @Column(name = "created_at", nullable = false, updatable = false)
    private OffsetDateTime createdAt;

    @NotNull
    @Column(name = "updated_at", nullable = false)
    private OffsetDateTime updatedAt;

    @Version
    @Column(name = "version", nullable = false)
    private Long version;

    // Helper for toString to avoid recursion if Plot toString includes LandTenure
    @Transient // Not persisted
    private UUID getPlotIdentifierForToString() {
        return plot != null ? plot.getPlotIdentifier() : null;
    }

    @PrePersist
    protected void onCreate() {
        updatedAt = createdAt = OffsetDateTime.now();
        // landTenureIdentifier is generated by @UuidGenerator on persist
        if (plot != null) { // Ensure tenantId consistency if not already set
            this.tenantId = plot.getTenantId();
        }
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = OffsetDateTime.now();
        if (plot != null) { // Ensure tenantId consistency
            this.tenantId = plot.getTenantId();
        }
    }
}